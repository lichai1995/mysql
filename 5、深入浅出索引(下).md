如果执行select * from T where k between 3 and 5，需要执行几次树的搜索操作。

<img src="/Users/lichai/Library/Application Support/typora-user-images/image-20210111182110362.png" alt="image-20210111182110362" style="zoom:50%;" />

现在，我们一起来看看这条SQL查询语句的执行流程：

1、在k索引树上找到k=3的记录，取得ID=300；

2、再到ID索引上查到ID=300对应的R3；

3、在k索引树取下一个值k=5，取得ID=500；

4、在回到ID索引树查到ID=500对应的R4；

5、在k索引树取下一个值k=6，不满足条件，循环结束。

在这个过程中，回到主键索引树搜索的过程，我们称为回表。

在这个过程中，回到主键索引树搜索的过程，我们称为回表。可以看到，这个查询过程读了k搜索树的3条记录(步骤1、3和5)，回表了两次(步骤2和4)

在这个例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。那么，有没有可能经过索引优化，避免回表过程呢？

#### 覆盖索引

如果执行的语句是select ID from T where k between 3 and 5，这时只需要查ID的值，而ID的值已经在索引树了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经"覆盖了"我们的查询需求，我们称为覆盖索引。

##### 由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。

我们知道，身份证号是市民的唯一标识，也就是说，如果有根据身份证号查询市民信息的需求，我们只要在身份证号字段上建立索引就够了。而在建立一个(身份证号、姓名)的联合索引，是不是浪费空间？

如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。他可以在这个高频请求上用到覆盖索引，不在需要回表查整行记录，减少语句的执行时间。

#### 最左前缀原则

B+树这种索引结构，可以利用索引的"最左前缀"，来定位记录。

这里最左前缀可以是联合索引的最左N个字段，也可以是字符串所以的最左M个字符。

##### 在建立联合索引的时候，如何安排索引内的字段顺序。

##### 第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。

#### 索引下推

```/
select * from tuser where name like '张%' and age = 10 and ismale = 1
```

在MySQL5.6之前，只能从ID3开始一个个回表。到主键索引上找出数据行，在对比字段值。

在MySQL5.6之后，引入索引下推优化，可以在索引遍历过程中，对比索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

<img src="/Users/lichai/Library/Application Support/typora-user-images/image-20210111184946010.png" alt="image-20210111184946010" style="zoom:50%;" />

<img src="/Users/lichai/Library/Application Support/typora-user-images/image-20210111185032947.png" alt="image-20210111185032947" style="zoom:50%;" />

图3中，在(name，age)索引里面我特意去掉了age的值，这个过程InnoDB并不会去看age的值，只是按顺醋把"name第一个字是'张'"的记录一条条取出来回表。因此，需要回表4次。

图4跟图3的区别是，InnoDB在(name，age)索引内部就判断了age是否等于10，对于不等于10的记录，直接判断并跳过，在我们的这个例子中，只需要对ID4、ID5这两条记录回表取数据判断，就只需要回表两次。

