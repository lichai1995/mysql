### 一条更新语句的执行流程是怎么样的

MySQL可以恢复到半个月内任意一秒的状态

我们还是从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键ID和一个整形字段C：

```/
create table T(ID int primary key, c int)
```

如果要将ID=2这一行的值加1，SQL语句就会这么写

```/
update T set c=c+1 where ID = 2
```

在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表T所有缓存结果都清空。这就是我们一般不建议使用查询缓存的原因。

接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用ID这个索引。然后，执行器负责具体执行，找到这一行，然后更新。

与查询流程不一样的事，更新流程还涉及两个重要的日志模块，redo log(重做日志)和binlog(归档日志)

#### 重要的日志模块 redo log(重做日志)

如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。

而粉板和账本配合的整个过程，其实就是MySQL里经常说到的WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，在写磁盘，也就是先写粉板，等不忙的时候在写账本。

具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log(粉板)里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。

如果今天赊账的不多，掌柜可以等打烊后在整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。

与此类似，InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么这块"粉板"总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。

![image-20210106171532993](/Users/lichai/Library/Application Support/typora-user-images/image-20210106171532993.png)

write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦掉的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。

Write pos和checkpoint之间的"粉板"上还空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示"粉板"满了，这时候不能在执行新的更新，得停下来先擦掉一些记录，把checkpoint推进以下。

有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。



#### 重要的日志模块 binlog(归档日志)

这两种日志有以下三点不同

1、redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。

2、redo log是物理日志(存储了数据被修改的值)；binlog是逻辑日志(存储了逻辑SQL修改语句)，记录的是这个语句的原始逻辑，比如"给ID=2这一行的c字段加1"

3、redo log是循环写的，空间固定会用完；binlog是可以追加写入的。"追加写"是指binlog文件写到一定大小会切换到下一个，并不会覆盖以前的日志。

>  有了对这两个日志的概念理解，我们再来看执行器和InnoDB引擎在执行这个简单的update语句时的内存流程

1、执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要从磁盘读入内存，然后在返回。

2、执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，在调用引擎接口写入这行新数据。

3、引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。

4、执行器生成这个操作的binlog，并把binlog写入磁盘。

5、执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交状态，更新完成。

> 这里给出这个update语句的执行流程图，图中浅色框表示是在InnoDB内部执行的，深色框表示是在执行器中执行的

![image-20210106183507086](/Users/lichai/Library/Application Support/typora-user-images/image-20210106183507086.png)

你可能注意到了，最后散步看上去有点绕，将redo log的写入拆成了两个步骤：prepare和commit，这就是两阶段提交。

#### 两阶段提交

为什么会有两阶段提交？

1、先写redo log 后写binlog。假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。

2、先写binlog后写redo log。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0.但是binlog里面已经记录了，把c从0改成1这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。

简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上一致。



#### 小结

MySQL里面最重要的两个日志，即物理日志redo log和逻辑日志binlog。

redo log用于保证crash-safe能力。innodb_flush_log_at_trx_commit这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。这个参数我建议可以设置成1，这样可以保证MySQL异常重启之后数据不丢失。

##### innodb_flush_log_at_trx_commit

1、该值为1时，表示事务提交必须调用一次fsync参数，当然是最安全的，但是数据库性能会受到一定影响。

2、该值为0时，表示事务提交不写入磁盘，写入过程在master thread中进行。master thread是InnoDB一个后台运行的主线程，它做的主要工作并不限于：刷新日志缓冲，合并插入缓冲，刷新脏页等。master thread大致分为每秒运行一次的操作和每10秒运行一次的操作。

3、该值为2时，表示事务提交时不写入重做日志文件，而是写入文件系统缓冲中。当DB发生故障能恢复数据。但如果操作系统也出现宕机，那么就会丢失掉，文件系统没有及时写入磁盘的数据。





Sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。这个参数我也建议你设置成1，这样可以保证MySQL异常重启之后binlog不丢失。





