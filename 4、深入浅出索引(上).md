索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。

#### 索引的常见模型

哈希表、有序数组和搜索树

哈希表是一种以键-值(key - value)存储数据的结构，我们只要输入待查找的值即key，就可以找到其对应的值即Value，哈希的思路很简单，把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。

不可避免地，多个key值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一个方法是，拉出一个链表。

哈希表这种结构适用于只有等值查询的场景。

有序数组在等值查询和范围查询场景中的性能就都非常优秀。有序数组索引只适用于静态存储引擎。

二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。时间复杂度是O(long(N))

当然为了维持O(log(N))的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是O(log(N))。

树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。

你可以想象一下一课100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要10ms左右的寻址时间。也就是说，对于一个100万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10ms的时间，这个查询可真够慢的。

为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是使用"N叉"树，"N叉"树中的"N"取决于数据块的大小。

以InnoDB的一个整数字段索引为例，这个N差不多是1200，这棵树高是4的时候，就可以存1200的3次方个值，这就已经17亿了。考虑到树根的数据总是在内存中，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次树就更少了。

在MySQL中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样，而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。由于InnoDB存储引擎在MySQL数据库中使用最为广泛，所以下面就以InnoDB为例，分析一下其中索引模型。

#### InnoDB的索引模型

在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。

每一个索引在InnoDB里面对应一棵B+树。

假设，我们有一个主键列为ID的表，表中有字段k，并且k上有索引。

```/
create table T(id int primary key, k int not null, name varchar(16), index(x) engine=InnoDB)
```

表中R1~R5的(ID，k)值分别为(100，1)、(200， 2)、(300， 3)、(500，5)和(600，6)，两棵树的示例图如下。

<img src="/Users/lichai/Library/Application Support/typora-user-images/image-20210108162101283.png" alt="image-20210108162101283" style="zoom:50%;" />

从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。

主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引。

非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引。

##### 基于主键索引和普通索引的查询有什么区别?

如果语句是select * from T where ID = 500，即主键查询方式，则只需要搜索ID这棵B+树；

如果语句是select * from T where k = 5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。

也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。

#### 索引维护

B+树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果新的行ID值为700，则只需要在R5的记录后面插入一个新记录。如果新插入的ID值为400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。

而更糟的情况是，如果R5所在的数据页已经满了，根据B+树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分类。在这种情况下，性能自然会受影响。

除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。

当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。

由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约20个字节，而如果用整型做主键，则只要4个字节，如果是长整形则是8个字节。

##### 主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小

所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。

#### 小结

B+树能够很好的配合磁盘的读写特性，减少单次查询的磁盘访问次数。由于InnoDB是索引组织表，一般情况下我会建议你创建一个自增主键，这样非主键索引占用的空间最小。

















