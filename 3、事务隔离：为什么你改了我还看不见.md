#### 隔离性与隔离级别

提到事务，肯定就想到ACID(Atomicity、Consistency、Isolation、Durability即原子性、一致性、隔离性、持久性)

当数据库上有多个事务同时执行的时候，就可能出现脏读、不可重复读、幻读的问题。

SQL标准的事务隔离级别包括：读未提交、读提交、可重复读和串行化

读未提交是指：一个事务还没有提交时，它做的变更就能被别的事务看到。

读提交是指：一个事务提交之后，它做的变更才会被其他事务看到。

可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。

串行化，顾名思义是对于同一行记录，"写"会加"写锁"，"读"会加"读锁"。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

<img src="/Users/lichai/Library/Application Support/typora-user-images/image-20210107111326149.png" alt="image-20210107111326149" style="zoom:50%;" />

若隔离级别是"读未提交"，则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被A看到了。因此，V2、V3也都是2.

若隔离级别是"读提交"，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以，V3的值也是2。

若隔离级别是"可重复读"，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求，事务在执行期间看到的数据前后必须是一致的。

若隔离级别是"串行化"，则在事务B执行"将1改成2"的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看，V1、V2的值是1，V3的值是2。

我们可以看到在不同的隔离级别下，数据库行为是有所不同的。Oracle数据库的默认隔离级别其实就是"读提交"，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致，记得要将MySQL的隔离级别设置为"读提交"

配置的方式是，将启动参数transaction-isolation的值设置成READ-COMMITED。你可以用show variable来查看当前的值。

<img src="/Users/lichai/Library/Application Support/typora-user-images/image-20210107141516221.png" alt="image-20210107141516221" style="zoom:50%;" />

#### 事务隔离的实现

理解了事务的隔离级别，我们再来看看事务隔离具体是怎么实现的。这里我们展开说"可重复读"

在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。

假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。

<img src="/Users/lichai/Library/Application Support/typora-user-images/image-20210107155540357.png" alt="image-20210107155540357" style="zoom:50%;" />

当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制(MVCC)。对于read-viewA，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。

同时你会发现，即使现在有另外一个事务正在将4改成5，这个事务跟read-view A、B、C对应的事务是不会冲突的。

##### 什么时候删除回滚日志?

当系统里没有比这个回滚日志更早的read-view的时候。

基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。

长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。

在MySQL5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有20GB，而回滚段有200GB的库。最终只好为了清理回滚段，重建整个库。

#### 事务的启动方式

1、显示启动事务语句，begin或start transaction。配套的提交语句是commit，回滚语句是rollback。

2、set autocommit=0，这个命令会将这个县城的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit或rollback语句，或者断开连接。

